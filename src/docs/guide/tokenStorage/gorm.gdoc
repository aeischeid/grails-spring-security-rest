To use GORM, these are the relevant configuration properties:

{table}
*Config key*                                                                    | *Default value*
@grails.plugin.springsecurity.rest.token.storage.useGorm@                       | @false@
@grails.plugin.springsecurity.rest.token.storage.gorm.tokenDomainClassName@     | @null@
@grails.plugin.springsecurity.rest.token.storage.gorm.tokenValuePropertyName@   | @tokenValue@
@grails.plugin.springsecurity.rest.token.storage.gorm.usernamePropertyName@     | @username@
{table}

The relevant domain class should look something like this:

{code}
package org.my.path

class AuthenticationToken {

    String tokenValue
    String username

    static mapping = {
        version false
    }
}
{code}

{note}
For the @tokenDomainClassName@ configuration you must enter a fully qualified class name. In the case of the example above:
@grails.plugin.springsecurity.rest.token.storage.gorm.tokenDomainClassName = 'org.my.path.AuthenticationToken'@
{note}

A few things to take into consideration when using GORM for token storage:

* Instead of storing the whole @UserDetails@ object, probably only the username is needed. This is because applications
using this strategy will probably have the standard User and Role domain classes. When the token is verified the username
is passed to the default @userDetailsService@ bean, which in the case of the default Spring Security Core GORM
implementation will fetch the information from the mentioned domain classes.
* GORM's optimistic locking feature is likely unecessary and may cause performance issues.
* You'll have to handle token expiration by yourself via Quartz jobs or a similar mechanism. Using this in combination with
adding a GORM autoTimestamp property like @lastUpdated@ plus an access counter may work as a strategy to keepTokens fresh,
but doing a write to a disk based database on each token access may be something you would prefer to avoid for the sake of
performance.

{code}
    Date lastUpdated
    Integer accessCount = 0

    def afterLoad() {
      accessCount++
   }
{code}

For a less aggressive but more efficient/performant approach to dealing with token expiration in GORM see: [This Gist|https://gist.github.com/aeischeid/a290876c2e0c2918401b]
